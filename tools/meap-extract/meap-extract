#!/usr/bin/env ruby

require 'fileutils'
require 'find'
require 'optparse'
require 'ostruct'

$: << File.join(File.dirname(__FILE__), 'lib')

require 'threadpool'

CLASS_PATH = Dir.glob(File.join(File.dirname(__FILE__), "meap/*.jar"))
SEGMENTER = "com.meapsoft.Segmenter"
EXTRACTOR = "com.meapsoft.FeatExtractor"

DEFAULT_FEATURES = %w(
  AvgChroma
  AvgChromaScalar
  AvgChunkPower
  AvgFreqSimple
  AvgMelSpec
  AvgMFCC
  AvgPitchSimple
  AvgSpecCentroid
  AvgSpecFlatness
)

FEATURES = DEFAULT_FEATURES + %w(
  ChunkLength
  ChunkStartTime
  Likelihood
  SpectralStability
)

MEAP_FILE_REGEXP = /\.com\.meapsoft\.(cache|feat|seg)$/
SOUND_FILE_REGEXP = /\.(aif*|mp3|wav)$/i

class MeapOptionParser
  def initialize
    @options = OpenStruct.new
    @options.features = []
    @options.cache = true
    @options.clean = false
    @options.jobs  = 1
    @opts = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename($0)} [options] FILE_OR_DIRECTORY..."

      opts.separator ""
      opts.separator "Segmenter options:"

      opts.on("-t", "--tempo-scale [N]", Float, "tempo scale") do |arg|
        @options.tempo_scale = arg
      end

      opts.on("-s", "--smoothing-window [N]", Float, "smoothing window") do |arg|
        @options.smoothing_window = arg
      end

      opts.on("-d", "--[no-]old-onset-detector") do |arg|
        @options.old_onset_detector = arg
      end

      opts.on("-0", "--[no-]initial-onset") do |arg|
        @options.initial_onset = arg
      end

      opts.separator ""
      opts.separator "Extractor options:"

      opts.on("-w", "--fft-size [SIZE]", Integer, "FFT size") do |arg|
        @options.fft_size = arg
      end

      opts.on("-H", "--fft-hop [HOP]", Integer, "FFT hop") do |arg|
        @options.fft_hop = arg
      end

      # List of arguments.
      opts.on(
        "-f f1,f2,f3", "--features f1,f2,f3", Array,
        *["Valid features:", FEATURES, " ", "Default features:", DEFAULT_FEATURES].flatten) do |arg|
        @options.features = arg.sort
      end

      opts.separator ""
      opts.separator "Other options:"

      opts.on("-c", "--[no-]clean") do |arg|
        @options.clean = arg
      end

      opts.on("-C", "--[no-]cache") do |arg|
        @options.cache = arg
      end

      opts.on("-j", "--jobs [N]", Integer, "Allow N jobs at once") do |arg|
        @options.jobs = [1, arg].max
      end
      
      # No argument, shows at tail.  This will print an options summary.
      # Try it and see!
      opts.on_tail("-h", "--help", "Show this message") do
        self.help!
      end
    end
  end
  
  def help
    puts @opts
  end
  
  def help!
    self.help
    exit(0)
  end
  
  def parse(args)
    # The options specified on the command line will be collected in *options*.
    # We set default values here.
    @opts.parse!(args)
    @options
  end
end

class Cache
  def initialize(file, values)
    @file = file
    @values = values
  end
  def valid?(i)
    @values[i] == @cache[i]
  end
  def do
    begin
      @cache = File.readlines(@file).collect { |x| x.strip }
    rescue
      @cache = Array.new(@values.size)
    end
    yield self
    File.open(@file, "w") { |io|
      io.write(@values.join("\n"))
    }
  end
end

def mk_file(path, ext)
  path + ".com.meapsoft." + ext
end

def java(klass, args)
  system("java", "-mx1000m", "-cp", CLASS_PATH.join(":"), klass, *args)
end

def opt(flag, value)
  value ? [flag, value.to_s] : []
end

def process_file(options, input_file)
  segment_file  = mk_file(input_file, "seg")
  feat_file     = mk_file(input_file, "feat")
  cache_file    = mk_file(input_file, "cache")

  segmenter_options = [
    opt("-t", options.tempo_scale),
    opt("-s", options.smoothing_window),
    opt("-d", options.old_onset_detector),
    opt("-0", options.initial_onset)].flatten

  extractor_options = [
    opt("-w", options.fft_size),
    opt("-h", options.fft_hop),
    options.features.collect { |f| ["-f", f] }].flatten

  Cache.new(
    cache_file,
    [segmenter_options, extractor_options].collect { |x| ":" + x.join(":") + ":" }
  ).do { |cache|
    if !options.cache || !cache.valid?(0)
      puts "Running segmenter on #{input_file}..."
      unless java(SEGMENTER, [
        opt("-t", options.tempo_scale),
        opt("-s", options.smoothing_window),
        opt("-d", options.old_onset_detector),
        opt("-0", options.initial_onset),
        "-o", segment_file, input_file].flatten)
        raise "segmenter failed"
      end
    end

    if !options.cache || !(cache.valid?(0) && cache.valid?(1))
      puts "Running extractor on #{input_file}..."
      features = options.features.empty? ? DEFAULT_FEATURES : options.features
      unless java(EXTRACTOR, [
        opt("-w", options.fft_size),
        opt("-h", options.fft_hop),
        features.collect { |f| ["-f", f] },
        "-o", feat_file,
        segment_file].flatten)
        raise "extractor failed"
      end
    end
  }  
end

def process_files(options, input_path)
  if File.directory?(input_path)
    pool = ThreadPool.new(options.jobs)
    Find.find(input_path) do |file|
      if File.file?(file) && SOUND_FILE_REGEXP =~ file
        pool.process {
          begin
            process_file(options, file)
          rescue
            puts $!.backtrace
          end
        }
      end
    end
    pool.join()
  else
    process_file(options, input_path)
  end
end

def clean(input_path)
  if File.directory?(input_path)
    Find.find(input_path) do |file|
      if File.file?(file) && MEAP_FILE_REGEXP =~ file
        FileUtils.rm(file)
      end
    end
  end
end

option_parser = MeapOptionParser.new
options = option_parser.parse(ARGV)
if ARGV.size < 1
  option_parser.help!
end

ARGV.each { |input_path|
  if options.clean then
    clean(input_path)
  else
    process_files(options, input_path)
  end
}

# EOF